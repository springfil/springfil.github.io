// «стрелочные функции»  
let func = (arg1, arg2, ...argN) => expression;

// то же самое:
let func = function(arg1, arg2, ...argN) {
    return expression;
  };

// если параметр один, то опускаем ()
let func = arg => expression 

// () должны быть,если не параметров 
let func = () => console.log(9)

//Пример динамического создания функции 
let age = prompt("Сколько Вам лет?", 18);

let welcome = (age < 18) ?
  () => alert('Привет!') :
  () => alert("Здравствуйте!");

welcome()

//Многострочные стрелочные ф-ции.
let sum = (a, b) => {  // фигурная скобка, открывающая тело многострочной функции
    let result = a + b;
    return result; // если мы используем фигурные скобки, то нам нужно явно указать "return"
  };
  
  alert( sum(1, 2) ); // 3

// Стрелочные функции очень удобны для простых действий, особенно для однострочных.
// Они бывают двух типов:
// Без фигурных скобок: (...args) => expression – правая сторона выражения: функция вычисляет его
// и возвращает результат. Скобки можно не ставить, если аргумент только один: n => n * 2.

// С фигурными скобками: (...args) => { body } – скобки позволяют нам писать несколько
// инструкций внутри функции, но при этом необходимо явно вызывать return, чтобы вернуть значение.



// У обычных функций есть привязка к аргументам (arguments binding). 
// Поэтому когда вы передаете аргументы в обычную функцию, вы можете получить к ним доступ, 
// используя ключевое слово arguments. 

let x = function () {
    console.log(arguments);
}
x(4,6,7); // Вывод: Arguments [4, 6, 7]

// У стрелочных функций нет привязки к аргументами.
// Если вы пытаетесь получить доступ к аргументам стрелочной функции, JavaScript выдаст ошибку. 

let x = () => {
    console.log(arguments);
}

x(4,6,7); 
// ReferenceError: Can't find variable: arguments

// Чтобы решить эту проблему, можно использовать spread syntax .... 
let x = (...n) => {
    console.log(n);
}

x(4,6,7); // Вывод: [4, 6, 7]