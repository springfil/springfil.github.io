// !!! Отличие обьекта от примитивов состоит в том, что
// он копируется и хранится по ссылке, что значит
//Переменная, которой присвоен объект, хранит 
//не сам объект, а его «адрес в памяти» – другими словами, «ссылку» на него.

let user = {// user, как лист бумаги с адресом объекта на нем.
    name: "John"
  };

//берем св-во user.name, движок JavaScript просматривает то, 
//что находится по этому адресу, и выполняет операцию с самим объектом.

//!! При копировании переменной объекта копируется ссылка, но сам объект не дублируется.
let user = { name: "John" };
let admin = user; // копируется ссылка

//Мы можем использовать любую переменную для доступа к объекту и изменения его содержимого:
let user = { name: 'John' };
let admin = user;
admin.name = 'Pete'; // изменено по ссылке из переменной "admin"
alert(user.name); // 'Pete', изменения видны по ссылке из переменной "user"


//Сравнение по ссылке 
// два {} равны, если это один и тот же обьект 
let a = {};
let b = a; // копирование по ссылке
alert( a == b ); // true, обе переменные ссылаются на один и тот же объект
alert( a === b ); // true
//И здесь два независимых объекта не равны, даже если они выглядят одинаково (оба пусты):
let a = {};
let b = {}; // два независимых объекта
alert( a == b ); // false

// при такой залупе obj1 > obj2 / obj == 5 - obj приводится к примитиву 



//Клонирование и объединение, Object.assign 
// если нам все-таки нужен клон,  то нам нужно создать новый объект и 
//воспроизвести структуру существующего, перебрав его свойства и скопировав их на примитивном уровне.
let user = {
    name: "John",
    age: 30
  };
  let clone = {}; // новый пустой объект
  // давайте скопируем все свойства user в него
  for (let key in user) {
    clone[key] = user[key];
  }
  // теперь clone это полностью независимый объект с тем же содержимым
  clone.name = "Pete"; // изменим в нём данные
  alert( user.name ); // все ещё John в первоначальном объекте

//Также мы можем использовать для этого метод Object.assign.
Object.assign(dest, [src1, src2, src3...])
// Первый аргумент dest — целевой объект.
// Остальные аргументы src1, ..., srcN (может быть столько, сколько необходимо) являются исходными объектами

// Метод копирует свойства всех исходных объектов src1, ..., srcN в целевой объект dest. 
// Другими словами, свойства всех аргументов, начиная со второго, копируются в первый объект.

// Возвращает объект dest.
let user = { name: "John" };
let permissions1 = { canView: true };
let permissions2 = { canEdit: true };
// копируем все свойства из permissions1 и permissions2 в user
Object.assign(user, permissions1, permissions2);
// теперь user = { name: "John", canView: true, canEdit: true }
//Если скопированное имя свойства уже существует, оно будет перезаписано

//Мы также можем использовать Object.assign для замены цикла for..in для простого клонирования:
let user = {
    ...
  }; 
let clone = Object.assign({}, user); //копирует все свойства user в пустой объект и возвращает его.


//Вложенное клонирование
let user = {
    name: "John",
    sizes: {
      height: 182,
      width: 50
    }
  };
  let clone = Object.assign({}, user);
  alert( user.sizes === clone.sizes ); // true, тот же объект
  // user и clone обладают общим свойством sizes
  user.sizes.width++;       // изменяем свойства в первом объекте
  alert(clone.sizes.width); // 51, видим результат в другом

// Нужно использовать цикл клонирования, который проверяет каждое значение user[key] и, если это 
// объект, тогда также копирует его структуру. Это называется «глубоким клонированием».
//глобальный метод structuredClone()
/*
Итого
Объекты присваиваются и копируются по ссылке. Другими словами, переменная хранит не «значение объекта», 
а «ссылку» (адрес в памяти) на это значение. Таким образом, копирование такой переменной или передача 
её в качестве аргумента функции копирует эту ссылку, а не сам объект.

Все операции с использованием скопированных ссылок (например, добавление/удаление свойств) выполняются 
с одним и тем же объектом.

Чтобы создать «реальную копию» (клон), мы можем использовать Object.assign для так называемой 
«поверхностной копии» (вложенные объекты копируются по ссылке) или функцию «глубокого клонирования», 
такую как _.cloneDeep(obj).*/