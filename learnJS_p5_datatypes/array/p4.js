//Массивы
let arr = new Array();
let arr = [];

let fruits = ["Яблоко", "Апельсин", "Слива"];
alert( fruits[0] ); // Яблоко
alert( fruits[1] ); // Апельсин
alert( fruits[2] ); // Слива

// можем заменять /добавлять по индексу
//В массиве могут храниться элементы любого типа.

let arr = [ 'Яблоко', { name: 'Джон' }, true, function() { alert('привет'); } ];

// получить элемент с индексом 1 (объект) и затем показать его свойство
alert( arr[1].name ); // Джон

// получить элемент с индексом 3 (функция) и выполнить её
arr[3](); // привет



//Получение последних элементов при помощи «at»
let fruits = ["Apple", "Orange", "Plum"];
alert( fruits[fruits.length-1] ); // Plum
alert( fruits.at(-1) ); // Plum 



// Методы pop/push, shift/unshift
// Очередь – один из самых распространённых вариантов применения массива. 
// В области компьютерных наук так называется упорядоченная коллекция элементов,

// push добавляет элемент в конец.
// shift удаляет элемент в начале, сдвигая очередь, так что второй элемент становится первым

// Существует и другой вариант применения для массивов – структура данных, называемая стек.
// push добавляет элемент в конец.
// pop удаляет последний элемент т возвращает его

let fruits = ["Яблоко", "Апельсин", "Груша"];
alert( fruits.pop() ); // удаляем "Груша" и выводим его
alert( fruits ); // Яблоко, Апельсин


// push
// Добавляет элемент в конец массива:
let fruits = ["Яблоко", "Апельсин"];
fruits.push("Груша");
alert( fruits ); // Яблоко, Апельсин, Груша
//Вызов fruits.push(...) равнозначен fruits[fruits.length] = ....

let fruits = ["Апельсин", "Груша"];
fruits.unshift('Яблоко');
alert( fruits ); // Яблоко, Апельсин, Груша

let fruits = ["Яблоко", "Апельсин", "Груша"];
alert( fruits.shift() ); // удаляем Яблоко и выводим его
аlert( fruits ); // Апельсин, Груша



//как устроено
// Массив – это особый подвид объектов. Квадратные скобки,
//  используемые для того, чтобы получить доступ к свойству arr[0]
//  – это по сути обычный синтаксис доступа по ключу, как obj[key], 
//  где в роли obj у нас arr, а в качестве ключа – числовой индекс.
let fruits = ["Банан"]

let arr = fruits; // копируется по ссылке (две переменные ссылаются на один и тот же массив)

alert( arr === fruits ); // true

arr.push("Груша"); // массив меняется по ссылке

alert( fruits ); // Банан, Груша - теперь два элемента

// Варианты неправильного применения массива:
// Добавление нечислового свойства, например: arr.test = 5.
// Создание «дыр», например: добавление arr[0], затем arr[1000] (между ними ничего нет).
// Заполнение массива в обратном порядке, например: arr[1000], arr[999] и т.д.



//Перебор элементов
//Цикл for..of не предоставляет доступа к номеру текущего элемента
//Цикл for..in плохая идея


//Таким образом, самый простой способ очистить массив – это arr.length = 0;.



///new Array()
// Если new Array вызывается с одним аргументом, 
// который представляет собой число, он создаёт массив без элементов, но с заданной длиной.
let arr = new Array(2); // создастся ли массив [2]?
alert( arr[0] ); // undefined! нет элементов.
alert( arr.length ); // length 2


//Многомерные массивы
let matrix = [
    [1, 2, 3],
    [4, 5, 6],
    [7, 8, 9]
  ];
  
  alert( matrix[1][1] ); // 5, центральный элемент



//toString  возвращает список элементов, разделённых запятыми.
let arr = [1, 2, 3];
alert( arr ); // 1,2,3
alert( String(arr) === '1,2,3' ); // true

alert( [] + 1 ); // "1"
alert( [1] + 1 ); // "11"
alert( [1,2] + 1 ); // "1,21"
// Массивы не имеют ни Symbol.toPrimitive, 
// ни функционирующего valueOf, они реализуют только преобразование toString, таким образом,
//  здесь [] становится пустой строкой, [1] становится "1", а [1,2] становится "1,2".


// после того, как [] был преобразован в ''
alert( 0 == '' ); // true, так как '' преобразуется в число 0
alert('0' == '' ); // false, нет преобразования типов, разные строки