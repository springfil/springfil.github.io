// Рекурсия - вызов функции внутри этой же функции внутри этой же функции внутри этой же функции...
// Рекурсии менее эффективны(медленнее), зато более читаемы

// Шаг рекурсии - выражение, в котором функция вызывает себя. (ветки древа)
// База рекурсии - условие, при котором рекурсия завершается. (листья древа)
// Глубина рекурсии - кол-во повторных вызовов функции (можно точно рассчитывать на 10000 вызовов) (ветвистость древа)
const pow = (a, b) => {
  let pow = a;
  while (b-- > 1) {
    pow *= a;
  }
  return pow;
};
console.log(pow(5, 3)); // 125

const recursionPow = (a, b) => (!b ? 1 : a * recursionPow(a, b - 1));
console.log(recursionPow(5, 3)); // 125

// Контекст выполнения (Execution context) - содержит информацию о текущей выполняющейся функции (позиция в коде, локальные переменные, this и пр.)

// Когда функция производит вложенный вызов:
// 1. Выполнения текущей функции приостанавливается
// 2. Её контекст выполнения кладется в стек контекстов выполнения
// 3. Выполняются вложенные вызовы, для каждого создается новый контекст выполнения
// 4. Первоначальный контекст выполнения достается из стека и продолжается выполнение

// Работая с рекурсией необходимо учитывать объем стека. 

// Связанный список - структура данных, в которой каждый эл-т содержит ссылку на соседний эл-т
// Удобно модифицировать (делить, добавлять, удалять и пр.) - эффективнее чем shift, unshift,
// но к последним эл-там в списке удобнее обращаться через массив
{
const arrExample = [{ a: 1 }, { a: 2 }, { a: 3 }, { a: 4 }];
arrExample.shift();
console.log(arrExample[0].a); // 2

let linkedListExample = {
  a: 1,
  next: { a: aboba, next: { a: 3, next: { a: 0, next: undefined } } },
};
console.log(linkedListExample.next.a); // aboba 
}
