// Замыкание - внутренняя функция, которая может получить доступ к тому контексту(переменным), где она создана.
// По умолчанию лучше реализовывать конструкторы функций через замыкание, тк инкапсуляция. А когда нужен доступ до переменных, использовать Конструктор (св-ва объекта и this)
let x = 10;

function foo() {
  console.log(x);
}
function bar(funArg) {
  let x = 20;
  funArg(); // 10 (тк область видимости где создана, а не где вызвана функция)
}
bar(foo);

// Лексическое окружение (LexicalEnvironment) - недоступный объект, который содержит информацию о конкретной функции\блоке\скрипте, состоит из:
// 1. Environment Record - объект, в котором хранятся локальные переменные и некоторая информация типа this
// 2. [[Environment]] - Когда создается функция, она получает ссылку на внешнее лексическое окружение.

// [[Environment]] не меняется (в отличие от this) и обеспечивает достижимость родительского эл-та, пока внутренняя функция жива.
// (!) При каждом выполнении функции создается новое лексическое окружение, ссылающееся на родительский эл-т

// Замыканию тесно связано с возвратом(return) функции и цепочками вызовов ()()()()

const makeCounter = function () {
  let counter = 0;

  return function () {
    return counter++;
  };
};
const foo1 = makeCounter();
const foo2 = makeCounter();
console.log(foo1()); // 0
console.log(foo1()); // 1
console.log(foo2()); // 0

const foo3 = foo1;
console.log(foo3()); // 2

console.log(makeCounter()()); // 0
console.log(makeCounter()()); // 0
console.log(makeCounter()()); // 0

// Переменные на самом деле это св-ва Environment Record
// Код сначала ищет переменные в текущей функции, потом во внешней, потом в след. внешней и тд

// Function Declaration подгружается в лексическое окружение заранее
// Function Expression подгружается когда до ее объявления(выражения) дойдет выполнение

// Лексическое окружение циклов создается каждую итерацию.
